'use strict';Object.defineProperty(exports,"__esModule",{value:true});var _from=require('babel-runtime/core-js/array/from');var _from2=_interopRequireDefault(_from);var _classCallCheck2=require('babel-runtime/helpers/classCallCheck');var _classCallCheck3=_interopRequireDefault(_classCallCheck2);var _createClass2=require('babel-runtime/helpers/createClass');var _createClass3=_interopRequireDefault(_createClass2);var _rapidMixAdapters=require('rapid-mix-adapters');function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}// source : https://stackoverflow.com/questions/15251879/how-to-check-if-a-variable-is-a-typed-array-in-javascript
var isArray=function isArray(v){return v.constructor===Float32Array||v.constructor===Float64Array||Array.isArray(v);};/**
 * Class modeling an example (time series of vectors that may represent a gesture).
 * If no parameters are given, the dimensions will be guessed from the first
 * added element after instantiation of the class and after each call to clear.
 * If parameters are given, they will be used to strictly check any new element,
 * anytime.
 *
 * @param {Number} [inputDimension=null] - If defined, definitive input dimension
 * that will be checked to validate any new element added.
 * @param {Number} [outputDimension=null] - If defined, definitive output dimension
 * that will be checked to validate any new element added.
 */var Example=function(){function Example(){var inputDimension=arguments.length>0&&arguments[0]!==undefined?arguments[0]:null;var outputDimension=arguments.length>1&&arguments[1]!==undefined?arguments[1]:null;(0,_classCallCheck3.default)(this,Example);if(inputDimension!==null){this.fixedDimensions=true;this.inputDimension=inputDimension;this.outputDimension=outputDimension!==null?outputDimension:0;}else{this.fixedDimensions=false;}this.label=_rapidMixAdapters.constants.rapidMixDefaultLabel;this._init();}/**
   * Append an element to the current example.
   *
   * @param {Array.Number|Float32Array|Float64Array} inputVector - The input
   * part of the element to add.
   * @param {Array.Number|Float32Array|Float64Array} [outputVector=null] - The
   * output part of the element to add.
   *
   * @throws An error if inputVector or outputVector dimensions mismatch.
   */(0,_createClass3.default)(Example,[{key:'addElement',value:function addElement(inputVector){var outputVector=arguments.length>1&&arguments[1]!==undefined?arguments[1]:null;this._validateInputAndUpdateDimensions(inputVector,outputVector);if(inputVector instanceof Float32Array||inputVector instanceof Float64Array)inputVector=(0,_from2.default)(inputVector);if(outputVector instanceof Float32Array||outputVector instanceof Float64Array)outputVector=(0,_from2.default)(outputVector);this.input.push(inputVector);if(this.outputDimension>0)this.output.push(outputVector);}/**
   * Reinit the internal variables so that we are ready to record a new example.
   */},{key:'clear',value:function clear(){this._init();}/**
   * Set the example's current label.
   *
   * @param {String} label - The new label to assign to the class.
   */},{key:'setLabel',value:function setLabel(label){this.label=label;}/**
   * Get the example in RapidMix format.
   *
   * @returns {Object} A RapidMix compliant example object.
   */},{key:'getExample',value:function getExample(){return{docType:'rapid-mix:example',docVersion:_rapidMixAdapters.constants.rapidMixDocVersion,payload:{label:this.label,// inputDimension: this.inputDimension,
// outputDimension: this.outputDimension,
input:this.input.slice(0),output:this.output.slice(0)}};}/** @private */},{key:'_init',value:function _init(){if(!this.fixedDimensions){this.inputDimension=null;this.outputDimension=null;}this.input=[];this.output=[];}/** @private */},{key:'_validateInputAndUpdateDimensions',value:function _validateInputAndUpdateDimensions(inputVector,outputVector){if(!isArray(inputVector)||outputVector&&!isArray(outputVector)){throw new Error('inputVector and outputVector must be arrays');}if(!this.inputDimension||!this.outputDimension){this.inputDimension=inputVector.length;this.outputDimension=outputVector?outputVector.length:0;// this._empty = false;
}else if(inputVector.length!=this.inputDimension||outputVector.length!=this.outputDimension){throw new Error('dimensions mismatch');}}}]);return Example;}();exports.default=Example;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImluZGV4LmpzIl0sIm5hbWVzIjpbImlzQXJyYXkiLCJ2IiwiY29uc3RydWN0b3IiLCJGbG9hdDMyQXJyYXkiLCJGbG9hdDY0QXJyYXkiLCJBcnJheSIsIkV4YW1wbGUiLCJpbnB1dERpbWVuc2lvbiIsIm91dHB1dERpbWVuc2lvbiIsImZpeGVkRGltZW5zaW9ucyIsImxhYmVsIiwicmFwaWRNaXhEZWZhdWx0TGFiZWwiLCJfaW5pdCIsImlucHV0VmVjdG9yIiwib3V0cHV0VmVjdG9yIiwiX3ZhbGlkYXRlSW5wdXRBbmRVcGRhdGVEaW1lbnNpb25zIiwiaW5wdXQiLCJwdXNoIiwib3V0cHV0IiwiZG9jVHlwZSIsImRvY1ZlcnNpb24iLCJyYXBpZE1peERvY1ZlcnNpb24iLCJwYXlsb2FkIiwic2xpY2UiLCJFcnJvciIsImxlbmd0aCJdLCJtYXBwaW5ncyI6IitaQUFBLG9ELG1GQUVBO0FBQ0EsR0FBTUEsU0FBVSxRQUFWQSxRQUFVLEdBQUssQ0FDbkIsTUFBT0MsR0FBRUMsV0FBRixHQUFrQkMsWUFBbEIsRUFDQUYsRUFBRUMsV0FBRixHQUFrQkUsWUFEbEIsRUFFQUMsTUFBTUwsT0FBTixDQUFjQyxDQUFkLENBRlAsQ0FHRCxDQUpELENBTUE7Ozs7Ozs7Ozs7O01BWU1LLFEsWUFDSixrQkFBMkQsSUFBL0NDLGVBQStDLDJEQUE5QixJQUE4QixJQUF4QkMsZ0JBQXdCLDJEQUFOLElBQU0sNENBQ3pELEdBQUlELGlCQUFtQixJQUF2QixDQUE2QixDQUMzQixLQUFLRSxlQUFMLENBQXVCLElBQXZCLENBQ0EsS0FBS0YsY0FBTCxDQUFzQkEsY0FBdEIsQ0FDQSxLQUFLQyxlQUFMLENBQXVCQSxrQkFBb0IsSUFBcEIsQ0FBMkJBLGVBQTNCLENBQTZDLENBQXBFLENBQ0QsQ0FKRCxJQUlPLENBQ0wsS0FBS0MsZUFBTCxDQUF1QixLQUF2QixDQUNELENBRUQsS0FBS0MsS0FBTCxDQUFhLDRCQUFrQkMsb0JBQS9CLENBQ0EsS0FBS0MsS0FBTCxHQUNELENBRUQ7Ozs7Ozs7OztvRkFVV0MsVyxDQUFrQyxJQUFyQkMsYUFBcUIsMkRBQU4sSUFBTSxDQUMzQyxLQUFLQyxpQ0FBTCxDQUF1Q0YsV0FBdkMsQ0FBb0RDLFlBQXBELEVBRUEsR0FBSUQsc0JBQXVCVixhQUF2QixFQUNBVSxzQkFBdUJULGFBRDNCLENBRUVTLFlBQWMsbUJBQVdBLFdBQVgsQ0FBZCxDQUVGLEdBQUlDLHVCQUF3QlgsYUFBeEIsRUFDQVcsdUJBQXdCVixhQUQ1QixDQUVFVSxhQUFlLG1CQUFXQSxZQUFYLENBQWYsQ0FFRixLQUFLRSxLQUFMLENBQVdDLElBQVgsQ0FBZ0JKLFdBQWhCLEVBRUEsR0FBSSxLQUFLTCxlQUFMLENBQXVCLENBQTNCLENBQ0UsS0FBS1UsTUFBTCxDQUFZRCxJQUFaLENBQWlCSCxZQUFqQixFQUNILENBRUQ7OzBDQUdRLENBQ04sS0FBS0YsS0FBTCxHQUNELENBRUQ7Ozs7K0NBS1NGLEssQ0FBTyxDQUNkLEtBQUtBLEtBQUwsQ0FBYUEsS0FBYixDQUNELENBRUQ7Ozs7b0RBS2EsQ0FDWCxNQUFPLENBQ0xTLFFBQVMsbUJBREosQ0FFTEMsV0FBWSw0QkFBa0JDLGtCQUZ6QixDQUdMQyxRQUFTLENBQ1BaLE1BQU8sS0FBS0EsS0FETCxDQUVQO0FBQ0E7QUFDQU0sTUFBTyxLQUFLQSxLQUFMLENBQVdPLEtBQVgsQ0FBaUIsQ0FBakIsQ0FKQSxDQUtQTCxPQUFRLEtBQUtBLE1BQUwsQ0FBWUssS0FBWixDQUFrQixDQUFsQixDQUxELENBSEosQ0FBUCxDQVdELENBRUQsZSxxQ0FDUSxDQUNOLEdBQUksQ0FBQyxLQUFLZCxlQUFWLENBQTJCLENBQ3pCLEtBQUtGLGNBQUwsQ0FBc0IsSUFBdEIsQ0FDQSxLQUFLQyxlQUFMLENBQXVCLElBQXZCLENBQ0QsQ0FFRCxLQUFLUSxLQUFMLENBQWEsRUFBYixDQUNBLEtBQUtFLE1BQUwsQ0FBYyxFQUFkLENBQ0QsQ0FFRCxlLDRGQUNrQ0wsVyxDQUFhQyxZLENBQWMsQ0FDM0QsR0FBSSxDQUFDZCxRQUFRYSxXQUFSLENBQUQsRUFBMEJDLGNBQWdCLENBQUNkLFFBQVFjLFlBQVIsQ0FBL0MsQ0FBdUUsQ0FDckUsS0FBTSxJQUFJVSxNQUFKLENBQVUsNkNBQVYsQ0FBTixDQUNELENBRUQsR0FBSSxDQUFDLEtBQUtqQixjQUFOLEVBQXdCLENBQUMsS0FBS0MsZUFBbEMsQ0FBbUQsQ0FDakQsS0FBS0QsY0FBTCxDQUFzQk0sWUFBWVksTUFBbEMsQ0FDQSxLQUFLakIsZUFBTCxDQUF1Qk0sYUFBZUEsYUFBYVcsTUFBNUIsQ0FBcUMsQ0FBNUQsQ0FDQTtBQUNELENBSkQsSUFJTyxJQUFJWixZQUFZWSxNQUFaLEVBQXNCLEtBQUtsQixjQUEzQixFQUNETyxhQUFhVyxNQUFiLEVBQXVCLEtBQUtqQixlQUQvQixDQUNnRCxDQUNyRCxLQUFNLElBQUlnQixNQUFKLENBQVUscUJBQVYsQ0FBTixDQUNELENBQ0YsQyx1Q0FHWWxCLE8iLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjb25zdGFudHMgYXMgcmFwaWRNaXhDb25zdGFudHMgfSBmcm9tICdyYXBpZC1taXgtYWRhcHRlcnMnO1xuXG4vLyBzb3VyY2UgOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xNTI1MTg3OS9ob3ctdG8tY2hlY2staWYtYS12YXJpYWJsZS1pcy1hLXR5cGVkLWFycmF5LWluLWphdmFzY3JpcHRcbmNvbnN0IGlzQXJyYXkgPSB2ID0+IHtcbiAgcmV0dXJuIHYuY29uc3RydWN0b3IgPT09IEZsb2F0MzJBcnJheSB8fFxuICAgICAgICAgdi5jb25zdHJ1Y3RvciA9PT0gRmxvYXQ2NEFycmF5IHx8XG4gICAgICAgICBBcnJheS5pc0FycmF5KHYpO1xufTtcblxuLyoqXG4gKiBDbGFzcyBtb2RlbGluZyBhbiBleGFtcGxlICh0aW1lIHNlcmllcyBvZiB2ZWN0b3JzIHRoYXQgbWF5IHJlcHJlc2VudCBhIGdlc3R1cmUpLlxuICogSWYgbm8gcGFyYW1ldGVycyBhcmUgZ2l2ZW4sIHRoZSBkaW1lbnNpb25zIHdpbGwgYmUgZ3Vlc3NlZCBmcm9tIHRoZSBmaXJzdFxuICogYWRkZWQgZWxlbWVudCBhZnRlciBpbnN0YW50aWF0aW9uIG9mIHRoZSBjbGFzcyBhbmQgYWZ0ZXIgZWFjaCBjYWxsIHRvIGNsZWFyLlxuICogSWYgcGFyYW1ldGVycyBhcmUgZ2l2ZW4sIHRoZXkgd2lsbCBiZSB1c2VkIHRvIHN0cmljdGx5IGNoZWNrIGFueSBuZXcgZWxlbWVudCxcbiAqIGFueXRpbWUuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IFtpbnB1dERpbWVuc2lvbj1udWxsXSAtIElmIGRlZmluZWQsIGRlZmluaXRpdmUgaW5wdXQgZGltZW5zaW9uXG4gKiB0aGF0IHdpbGwgYmUgY2hlY2tlZCB0byB2YWxpZGF0ZSBhbnkgbmV3IGVsZW1lbnQgYWRkZWQuXG4gKiBAcGFyYW0ge051bWJlcn0gW291dHB1dERpbWVuc2lvbj1udWxsXSAtIElmIGRlZmluZWQsIGRlZmluaXRpdmUgb3V0cHV0IGRpbWVuc2lvblxuICogdGhhdCB3aWxsIGJlIGNoZWNrZWQgdG8gdmFsaWRhdGUgYW55IG5ldyBlbGVtZW50IGFkZGVkLlxuICovXG5jbGFzcyBFeGFtcGxlIHtcbiAgY29uc3RydWN0b3IoaW5wdXREaW1lbnNpb24gPSBudWxsLCBvdXRwdXREaW1lbnNpb24gPSBudWxsKSB7XG4gICAgaWYgKGlucHV0RGltZW5zaW9uICE9PSBudWxsKSB7XG4gICAgICB0aGlzLmZpeGVkRGltZW5zaW9ucyA9IHRydWU7XG4gICAgICB0aGlzLmlucHV0RGltZW5zaW9uID0gaW5wdXREaW1lbnNpb247XG4gICAgICB0aGlzLm91dHB1dERpbWVuc2lvbiA9IG91dHB1dERpbWVuc2lvbiAhPT0gbnVsbCA/IG91dHB1dERpbWVuc2lvbiA6IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZml4ZWREaW1lbnNpb25zID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5sYWJlbCA9IHJhcGlkTWl4Q29uc3RhbnRzLnJhcGlkTWl4RGVmYXVsdExhYmVsO1xuICAgIHRoaXMuX2luaXQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBlbmQgYW4gZWxlbWVudCB0byB0aGUgY3VycmVudCBleGFtcGxlLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5Lk51bWJlcnxGbG9hdDMyQXJyYXl8RmxvYXQ2NEFycmF5fSBpbnB1dFZlY3RvciAtIFRoZSBpbnB1dFxuICAgKiBwYXJ0IG9mIHRoZSBlbGVtZW50IHRvIGFkZC5cbiAgICogQHBhcmFtIHtBcnJheS5OdW1iZXJ8RmxvYXQzMkFycmF5fEZsb2F0NjRBcnJheX0gW291dHB1dFZlY3Rvcj1udWxsXSAtIFRoZVxuICAgKiBvdXRwdXQgcGFydCBvZiB0aGUgZWxlbWVudCB0byBhZGQuXG4gICAqXG4gICAqIEB0aHJvd3MgQW4gZXJyb3IgaWYgaW5wdXRWZWN0b3Igb3Igb3V0cHV0VmVjdG9yIGRpbWVuc2lvbnMgbWlzbWF0Y2guXG4gICAqL1xuICBhZGRFbGVtZW50KGlucHV0VmVjdG9yLCBvdXRwdXRWZWN0b3IgPSBudWxsKSB7XG4gICAgdGhpcy5fdmFsaWRhdGVJbnB1dEFuZFVwZGF0ZURpbWVuc2lvbnMoaW5wdXRWZWN0b3IsIG91dHB1dFZlY3Rvcik7XG5cbiAgICBpZiAoaW5wdXRWZWN0b3IgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkgfHxcbiAgICAgICAgaW5wdXRWZWN0b3IgaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXkpXG4gICAgICBpbnB1dFZlY3RvciA9IEFycmF5LmZyb20oaW5wdXRWZWN0b3IpO1xuXG4gICAgaWYgKG91dHB1dFZlY3RvciBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSB8fFxuICAgICAgICBvdXRwdXRWZWN0b3IgaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXkpXG4gICAgICBvdXRwdXRWZWN0b3IgPSBBcnJheS5mcm9tKG91dHB1dFZlY3Rvcik7XG5cbiAgICB0aGlzLmlucHV0LnB1c2goaW5wdXRWZWN0b3IpO1xuXG4gICAgaWYgKHRoaXMub3V0cHV0RGltZW5zaW9uID4gMClcbiAgICAgIHRoaXMub3V0cHV0LnB1c2gob3V0cHV0VmVjdG9yKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWluaXQgdGhlIGludGVybmFsIHZhcmlhYmxlcyBzbyB0aGF0IHdlIGFyZSByZWFkeSB0byByZWNvcmQgYSBuZXcgZXhhbXBsZS5cbiAgICovXG4gIGNsZWFyKCkge1xuICAgIHRoaXMuX2luaXQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGV4YW1wbGUncyBjdXJyZW50IGxhYmVsLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbGFiZWwgLSBUaGUgbmV3IGxhYmVsIHRvIGFzc2lnbiB0byB0aGUgY2xhc3MuXG4gICAqL1xuICBzZXRMYWJlbChsYWJlbCkge1xuICAgIHRoaXMubGFiZWwgPSBsYWJlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGV4YW1wbGUgaW4gUmFwaWRNaXggZm9ybWF0LlxuICAgKlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBBIFJhcGlkTWl4IGNvbXBsaWFudCBleGFtcGxlIG9iamVjdC5cbiAgICovXG4gIGdldEV4YW1wbGUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRvY1R5cGU6ICdyYXBpZC1taXg6ZXhhbXBsZScsXG4gICAgICBkb2NWZXJzaW9uOiByYXBpZE1peENvbnN0YW50cy5yYXBpZE1peERvY1ZlcnNpb24sXG4gICAgICBwYXlsb2FkOiB7XG4gICAgICAgIGxhYmVsOiB0aGlzLmxhYmVsLFxuICAgICAgICAvLyBpbnB1dERpbWVuc2lvbjogdGhpcy5pbnB1dERpbWVuc2lvbixcbiAgICAgICAgLy8gb3V0cHV0RGltZW5zaW9uOiB0aGlzLm91dHB1dERpbWVuc2lvbixcbiAgICAgICAgaW5wdXQ6IHRoaXMuaW5wdXQuc2xpY2UoMCksXG4gICAgICAgIG91dHB1dDogdGhpcy5vdXRwdXQuc2xpY2UoMCksXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBfaW5pdCgpIHtcbiAgICBpZiAoIXRoaXMuZml4ZWREaW1lbnNpb25zKSB7XG4gICAgICB0aGlzLmlucHV0RGltZW5zaW9uID0gbnVsbDtcbiAgICAgIHRoaXMub3V0cHV0RGltZW5zaW9uID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLmlucHV0ID0gW107XG4gICAgdGhpcy5vdXRwdXQgPSBbXTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBfdmFsaWRhdGVJbnB1dEFuZFVwZGF0ZURpbWVuc2lvbnMoaW5wdXRWZWN0b3IsIG91dHB1dFZlY3Rvcikge1xuICAgIGlmICghaXNBcnJheShpbnB1dFZlY3RvcikgfHwgKG91dHB1dFZlY3RvciAmJiAhaXNBcnJheShvdXRwdXRWZWN0b3IpKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnB1dFZlY3RvciBhbmQgb3V0cHV0VmVjdG9yIG11c3QgYmUgYXJyYXlzJyk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmlucHV0RGltZW5zaW9uIHx8ICF0aGlzLm91dHB1dERpbWVuc2lvbikge1xuICAgICAgdGhpcy5pbnB1dERpbWVuc2lvbiA9IGlucHV0VmVjdG9yLmxlbmd0aDtcbiAgICAgIHRoaXMub3V0cHV0RGltZW5zaW9uID0gb3V0cHV0VmVjdG9yID8gb3V0cHV0VmVjdG9yLmxlbmd0aCA6IDA7XG4gICAgICAvLyB0aGlzLl9lbXB0eSA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoaW5wdXRWZWN0b3IubGVuZ3RoICE9IHRoaXMuaW5wdXREaW1lbnNpb24gfHxcbiAgICAgICAgICAgICAgb3V0cHV0VmVjdG9yLmxlbmd0aCAhPSB0aGlzLm91dHB1dERpbWVuc2lvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaW1lbnNpb25zIG1pc21hdGNoJyk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEV4YW1wbGU7XG4iXX0=